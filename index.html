<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒšã‚°ã‚½ãƒªãƒ†ã‚£ã‚¢</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Hiragino Kaku Gothic Pro', 'ãƒ¡ã‚¤ãƒªã‚ª', sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #4a6741 100%);
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      color: white;
      font-size: 1.8rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .info {
      color: white;
      text-align: center;
      margin-bottom: 15px;
    }

    .info p {
      margin: 5px 0;
      font-size: 1rem;
    }

    .status {
      background: rgba(255,255,255,0.2);
      padding: 8px 20px;
      border-radius: 20px;
      margin: 10px 0;
      font-size: 1.1rem;
    }

    .board {
      background: linear-gradient(145deg, #8B4513, #A0522D);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4), inset 0 2px 10px rgba(255,255,255,0.1);
    }

    .row {
      display: flex;
      justify-content: center;
    }

    .cell {
      width: 44px;
      height: 44px;
      margin: 2px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.15s;
    }

    .cell.invalid {
      background: transparent;
      cursor: default;
    }

    .cell.hole {
      background: radial-gradient(circle at 30% 30%, #5a3d2b, #3d2817);
      box-shadow: inset 0 3px 8px rgba(0,0,0,0.6);
    }

    .cell.peg {
      background: transparent;
    }

    .peg-ball {
      width: 36px;
      height: 36px;
      background: radial-gradient(circle at 30% 30%, #6eb5ff, #1e5aa8);
      border-radius: 50%;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 -2px 5px rgba(0,0,0,0.2);
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .cell.peg:hover .peg-ball {
      transform: scale(1.1);
      box-shadow: 0 6px 12px rgba(0,0,0,0.5);
    }

    .cell.selected .peg-ball {
      background: radial-gradient(circle at 30% 30%, #ffeb3b, #f9a825);
      transform: scale(1.15);
      box-shadow: 0 0 15px rgba(255,235,59,0.6);
    }

    .cell.movable {
      animation: pulse 0.8s infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: inset 0 3px 8px rgba(0,0,0,0.6); }
      50% { box-shadow: inset 0 3px 8px rgba(0,0,0,0.6), 0 0 15px rgba(100,255,100,0.6); }
    }

    /* é¸æŠãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒ›ãƒãƒ¼åŠ¹æœ */
    .selecting .cell.peg:hover .peg-ball {
      background: radial-gradient(circle at 30% 30%, #ff6b6b, #c0392b);
      transform: scale(1.1);
    }

    .buttons {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }

    button {
      padding: 12px 25px;
      font-size: 1rem;
      font-weight: bold;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
      color: white;
    }

    button:active {
      transform: scale(0.95);
    }

    .reset-btn {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      box-shadow: 0 4px 10px rgba(231,76,60,0.3);
    }

    .undo-btn {
      background: linear-gradient(135deg, #3498db, #2980b9);
      box-shadow: 0 4px 10px rgba(52,152,219,0.3);
    }

    .rules {
      color: white;
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      max-width: 350px;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    .rules h3 {
      margin-bottom: 10px;
      font-size: 1rem;
    }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      display: none;
      z-index: 100;
    }

    .message.show {
      display: block;
      animation: popIn 0.3s ease;
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .message h2 {
      font-size: 1.8rem;
      margin-bottom: 10px;
    }

    .message p {
      font-size: 1.1rem;
      margin-bottom: 20px;
    }

    .message button {
      background: linear-gradient(135deg, #27ae60, #1e8449);
    }
  </style>
</head>
<body>
  <h1>ãƒšã‚°ã‚½ãƒªãƒ†ã‚£ã‚¢</h1>
  
  <div class="info">
    <p class="status" id="statusText">ã®ã“ã‚Š: <span id="pegCount">35</span>å€‹</p>
  </div>

  <div class="board" id="board"></div>

  <div class="buttons">
    <button class="undo-btn" id="undoBtn">1æ‰‹ã‚‚ã©ã™</button>
    <button class="reset-btn" id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <div class="rules">
    <h3>ã‚ãã³ã‹ãŸ</h3>
    ãƒšã‚°ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸ã³ã€ã¨ãªã‚Šã®ãƒšã‚°ã‚’é£›ã³ã“ãˆã¦ç©ºã„ãŸç©´ã«ç§»å‹•ã—ã¾ã™ã€‚é£›ã³ã“ãˆãŸãƒšã‚°ã¯æ¶ˆãˆã¾ã™ã€‚æœ€å¾Œã«1å€‹ã ã‘æ®‹ã›ãŸã‚‰ã‚¯ãƒªã‚¢ï¼
  </div>

  <div class="message" id="message">
    <h2 id="messageTitle"></h2>
    <p id="messageText"></p>
    <button id="messageBtn">ã‚‚ã†ã„ã¡ã©</button>
  </div>

  <script>
    // åŠ¹æœéŸ³ã‚’é³´ã‚‰ã™ï¼ˆWeb Audio APIï¼‰
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      if (type === 'move') {
        oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.1);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.2);
      } else if (type === 'clear') {
        oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.4);
      } else if (type === 'gameover') {
        oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.3);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.3);
      } else if (type === 'select') {
        oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.1);
      }
    }

    // ç›¤é¢ã®å½¢ï¼ˆ1=ç©´ã‚ã‚Šã€0=ç©´ãªã—ï¼‰
    const boardShape = [
      [0, 0, 1, 1, 1, 0, 0],
      [0, 1, 1, 1, 1, 1, 0],
      [1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1],
      [0, 1, 1, 1, 1, 1, 0],
      [0, 0, 1, 1, 1, 0, 0]
    ];

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let board = [];
    let selectedCell = null;
    let moveHistory = [];
    let isSelectingStart = true;  // æœ€åˆã®ç©ºãä½ç½®é¸æŠãƒ¢ãƒ¼ãƒ‰
    const SIZE = 7;

    // åˆæœŸåŒ–ï¼ˆå…¨éƒ¨ãƒšã‚°ã§åŸ‹ã¾ã£ãŸçŠ¶æ…‹ï¼‰
    function initGame() {
      board = boardShape.map((row) => 
        row.map((cell) => {
          if (cell === 0) return -1;
          return 1;  // å…¨éƒ¨ãƒšã‚°ã‚ã‚Š
        })
      );
      selectedCell = null;
      moveHistory = [];
      isSelectingStart = true;
      document.getElementById('statusText').innerHTML = 'ç©ºã‘ã‚‹å ´æ‰€ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã­';
      document.getElementById('board').classList.add('selecting');
      renderBoard();
    }

    // ç›¤é¢æç”»
    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';

      for (let r = 0; r < SIZE; r++) {
        const rowEl = document.createElement('div');
        rowEl.className = 'row';

        for (let c = 0; c < SIZE; c++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.row = r;
          cellEl.dataset.col = c;

          if (board[r][c] === -1) {
            cellEl.classList.add('invalid');
          } else if (board[r][c] === 0) {
            cellEl.classList.add('hole');
            if (selectedCell && isValidMove(selectedCell.r, selectedCell.c, r, c)) {
              cellEl.classList.add('movable');
            }
          } else {
            cellEl.classList.add('peg');
            const ball = document.createElement('div');
            ball.className = 'peg-ball';
            cellEl.appendChild(ball);
            if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
              cellEl.classList.add('selected');
            }
          }

          cellEl.addEventListener('click', () => handleClick(r, c));
          rowEl.appendChild(cellEl);
        }

        boardEl.appendChild(rowEl);
      }
    }

    // ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
    function handleClick(r, c) {
      if (board[r][c] === -1) return;

      // æœ€åˆã®ç©ºãä½ç½®é¸æŠãƒ¢ãƒ¼ãƒ‰
      if (isSelectingStart) {
        if (board[r][c] === 1) {
          board[r][c] = 0;  // é¸ã‚“ã å ´æ‰€ã‚’ç©ºãã«
          isSelectingStart = false;
          document.getElementById('board').classList.remove('selecting');
          playSound('select');
          renderBoard();
          updateCount();
        }
        return;
      }

      // é€šå¸¸ã®ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤
      if (board[r][c] === 1) {
        if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
          selectedCell = null;
        } else {
          selectedCell = { r, c };
        }
        renderBoard();
        return;
      }

      if (board[r][c] === 0 && selectedCell) {
        if (isValidMove(selectedCell.r, selectedCell.c, r, c)) {
          makeMove(selectedCell.r, selectedCell.c, r, c);
          playSound('move');
          selectedCell = null;
          renderBoard();
          updateCount();
          checkGameEnd();
        }
      }
    }

    // æœ‰åŠ¹ãªç§»å‹•ã‹ãƒã‚§ãƒƒã‚¯
    function isValidMove(fromR, fromC, toR, toC) {
      const dr = toR - fromR;
      const dc = toC - fromC;

      if (!((Math.abs(dr) === 2 && dc === 0) || (dr === 0 && Math.abs(dc) === 2))) {
        return false;
      }

      if (board[toR][toC] !== 0) return false;

      const midR = fromR + dr / 2;
      const midC = fromC + dc / 2;
      if (board[midR][midC] !== 1) return false;

      return true;
    }

    // ç§»å‹•å®Ÿè¡Œ
    function makeMove(fromR, fromC, toR, toC) {
      const midR = fromR + (toR - fromR) / 2;
      const midC = fromC + (toC - fromC) / 2;

      moveHistory.push({
        from: { r: fromR, c: fromC },
        to: { r: toR, c: toC },
        mid: { r: midR, c: midC }
      });

      board[fromR][fromC] = 0;
      board[midR][midC] = 0;
      board[toR][toC] = 1;
    }

    // 1æ‰‹æˆ»ã™
    function undoMove() {
      if (isSelectingStart) return;
      if (moveHistory.length === 0) return;

      const last = moveHistory.pop();
      board[last.from.r][last.from.c] = 1;
      board[last.mid.r][last.mid.c] = 1;
      board[last.to.r][last.to.c] = 0;

      selectedCell = null;
      renderBoard();
      updateCount();
    }

    // ãƒšã‚°æ•°æ›´æ–°
    function updateCount() {
      let count = 0;
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === 1) count++;
        }
      }
      document.getElementById('statusText').innerHTML = `ã®ã“ã‚Š: <span id="pegCount">${count}</span>å€‹`;
    }

    // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
    function checkGameEnd() {
      let pegCount = 0;
      let canMove = false;

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === 1) {
            pegCount++;
            const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];
            for (const [dr, dc] of directions) {
              const toR = r + dr;
              const toC = c + dc;
              if (toR >= 0 && toR < SIZE && toC >= 0 && toC < SIZE) {
                if (isValidMove(r, c, toR, toC)) {
                  canMove = true;
                }
              }
            }
          }
        }
      }

      if (!canMove) {
        const messageEl = document.getElementById('message');
        const titleEl = document.getElementById('messageTitle');
        const textEl = document.getElementById('messageText');

        if (pegCount === 1) {
          titleEl.textContent = 'ğŸ‰ ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆï¼';
          textEl.textContent = 'ã™ã”ã„ï¼æœ€å¾Œã®1å€‹ã«ãªã‚Šã¾ã—ãŸï¼';
          playSound('clear');
        } else {
          titleEl.textContent = 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';
          textEl.textContent = `ã®ã“ã‚Š ${pegCount}å€‹ã§ã—ãŸ`;
          playSound('gameover');
        }

        messageEl.classList.add('show');
      }
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
    document.getElementById('resetBtn').addEventListener('click', initGame);
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('messageBtn').addEventListener('click', () => {
      document.getElementById('message').classList.remove('show');
      initGame();
    });

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    initGame();
  </script>
</body>
</html>