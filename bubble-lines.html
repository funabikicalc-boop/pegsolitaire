<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Lines</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Hiragino Kaku Gothic Pro', 'ãƒ¡ã‚¤ãƒªã‚ª', sans-serif;
      background: linear-gradient(180deg, #006994 0%, #003d5c 40%, #001f3f 100%);
      min-height: 100vh;
      padding: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      overflow: hidden;
    }

    /* æ³¡ã®èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    .bubble-bg {
      position: fixed;
      bottom: -20px;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 50%;
      animation: rise 8s infinite;
      opacity: 0.3;
      pointer-events: none;
    }

    @keyframes rise {
      0% { transform: translateY(0) scale(1); opacity: 0.3; }
      50% { opacity: 0.5; }
      100% { transform: translateY(-100vh) scale(0.5); opacity: 0; }
    }

    h1 {
      color: #7fdbff;
      font-size: 1.5rem;
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(127, 219, 255, 0.5);
      letter-spacing: 0.1em;
    }

    .info {
      color: #7fdbff;
      display: flex;
      gap: 20px;
      margin-bottom: 10px;
      font-size: 1rem;
    }

    .info span {
      background: rgba(0, 100, 150, 0.5);
      padding: 5px 15px;
      border-radius: 15px;
      border: 1px solid rgba(127, 219, 255, 0.3);
    }

    .next-balls {
      color: #7fdbff;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      font-size: 0.9rem;
    }

    .next-balls .preview-ball {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
    }

    .board {
      background: linear-gradient(180deg, rgba(0, 80, 120, 0.8), rgba(0, 40, 60, 0.9));
      padding: 8px;
      border-radius: 15px;
      box-shadow: 
        0 10px 40px rgba(0,0,0,0.5),
        inset 0 0 30px rgba(127, 219, 255, 0.1),
        0 0 60px rgba(0, 150, 200, 0.2);
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 2px;
      border: 2px solid rgba(127, 219, 255, 0.2);
    }

    .cell {
      width: 32px;
      height: 32px;
      background: rgba(0, 50, 80, 0.6);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.15s;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }

    .cell:hover {
      background: rgba(0, 80, 120, 0.8);
    }

    .cell.selected {
      background: rgba(0, 100, 150, 0.9);
      box-shadow: 
        inset 0 2px 4px rgba(0,0,0,0.3),
        0 0 15px rgba(127, 219, 255, 0.4);
    }

    .cell.path-highlight {
      background: rgba(100, 255, 100, 0.3);
    }

    /* æ³¡ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒœãƒ¼ãƒ« */
    .ball {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      transition: transform 0.15s;
      box-shadow: 
        inset -3px -3px 8px rgba(0,0,0,0.2),
        inset 3px 3px 8px rgba(255,255,255,0.4),
        0 2px 8px rgba(0,0,0,0.3);
    }

    .cell.selected .ball {
      transform: scale(1.1);
      animation: wobble 0.8s infinite;
    }

    @keyframes wobble {
      0%, 100% { transform: scale(1.1) translateY(0); }
      25% { transform: scale(1.1) translateY(-2px) rotate(-2deg); }
      75% { transform: scale(1.1) translateY(-2px) rotate(2deg); }
    }

    /* æ³¡ã®è‰² - ã‚«ãƒ©ãƒ•ãƒ«ãªæµ·ä¸­ã®å®çŸ³ã‚¤ãƒ¡ãƒ¼ã‚¸ */
    .ball.red { 
      background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff0044);
      box-shadow: 
        inset -3px -3px 8px rgba(100,0,0,0.3),
        inset 5px 5px 10px rgba(255,200,200,0.5),
        0 0 15px rgba(255,0,68,0.3);
    }
    .ball.blue { 
      background: radial-gradient(circle at 30% 30%, #74b9ff, #0066ff);
      box-shadow: 
        inset -3px -3px 8px rgba(0,0,100,0.3),
        inset 5px 5px 10px rgba(200,220,255,0.5),
        0 0 15px rgba(0,102,255,0.3);
    }
    .ball.green { 
      background: radial-gradient(circle at 30% 30%, #55efc4, #00cc66);
      box-shadow: 
        inset -3px -3px 8px rgba(0,80,0,0.3),
        inset 5px 5px 10px rgba(200,255,220,0.5),
        0 0 15px rgba(0,204,102,0.3);
    }
    .ball.yellow { 
      background: radial-gradient(circle at 30% 30%, #fff06b, #ffcc00);
      box-shadow: 
        inset -3px -3px 8px rgba(100,80,0,0.3),
        inset 5px 5px 10px rgba(255,255,220,0.5),
        0 0 15px rgba(255,204,0,0.3);
    }
    .ball.purple { 
      background: radial-gradient(circle at 30% 30%, #d589ff, #aa00ff);
      box-shadow: 
        inset -3px -3px 8px rgba(60,0,80,0.3),
        inset 5px 5px 10px rgba(240,200,255,0.5),
        0 0 15px rgba(170,0,255,0.3);
    }

    /* ç§»å‹•ä¸­ã®ãƒœãƒ¼ãƒ« */
    .ball.moving {
      position: fixed;
      z-index: 1000;
      pointer-events: none;
      transition: left 0.08s linear, top 0.08s linear;
    }

    /* æ°´æ³¡ãŒå¼¾ã‘ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
    .ball.removing {
      animation: bubblePop 0.5s ease-out forwards;
    }

    @keyframes bubblePop {
      0% { transform: scale(1); opacity: 1; }
      30% { transform: scale(1.3); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }

    /* å¼¾ã‘ã‚‹æ™‚ã®å°ã•ãªæ³¡ */
    .pop-bubble {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.3));
      pointer-events: none;
      z-index: 1001;
      animation: popFloat 0.8s ease-out forwards;
    }

    @keyframes popFloat {
      0% { transform: scale(1) translateY(0); opacity: 1; }
      100% { transform: scale(0.3) translateY(-40px); opacity: 0; }
    }

    /* è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
    .trail {
      position: fixed;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 999;
      animation: fadeTrail 0.4s ease-out forwards;
      box-shadow: 0 0 10px currentColor;
    }

    @keyframes fadeTrail {
      0% { transform: scale(1); opacity: 0.6; }
      100% { transform: scale(0.2); opacity: 0; }
    }

    .buttons {
      margin-top: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    button {
      padding: 10px 16px;
      font-size: 0.85rem;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.1s;
      color: white;
    }

    @media (max-width: 400px) {
      .buttons {
        gap: 8px;
      }
      
      button {
        padding: 8px 12px;
        font-size: 0.8rem;
      }
    }

    button:active {
      transform: scale(0.95);
    }

    .reset-btn {
      background: linear-gradient(135deg, #00a8cc, #006994);
      box-shadow: 0 4px 15px rgba(0, 168, 204, 0.4);
      border: 1px solid rgba(127, 219, 255, 0.3);
    }

    .reset-btn:hover {
      box-shadow: 0 4px 20px rgba(0, 168, 204, 0.6);
    }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(180deg, rgba(0, 80, 120, 0.95), rgba(0, 40, 60, 0.98));
      color: #7fdbff;
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      display: none;
      z-index: 100;
      border: 2px solid rgba(127, 219, 255, 0.3);
      box-shadow: 0 0 50px rgba(0, 150, 200, 0.3);
      width: 90%;
      max-width: 340px;
    }

    @media (max-width: 400px) {
      .message {
        padding: 20px 15px;
        width: 92%;
      }
      
      .message h2 {
        font-size: 1.4rem;
      }
      
      .message p {
        font-size: 1rem;
      }
    }

    .message.show {
      display: block;
      animation: popIn 0.3s ease;
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .message h2 {
      font-size: 1.8rem;
      margin-bottom: 10px;
      color: #ff6b6b;
      text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
    }

    .message p {
      font-size: 1.1rem;
      margin-bottom: 20px;
    }

    .message button {
      background: linear-gradient(135deg, #00cc66, #009944);
      box-shadow: 0 4px 15px rgba(0, 204, 102, 0.4);
    }

    .score-form {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
      justify-content: center;
    }

    .score-form input {
      padding: 8px 12px;
      border: 2px solid rgba(127, 219, 255, 0.4);
      border-radius: 8px;
      background: rgba(0, 40, 60, 0.8);
      color: #7fdbff;
      font-size: 16px;
      width: 140px;
      max-width: 100%;
    }

    .score-form input::placeholder {
      color: rgba(127, 219, 255, 0.5);
    }

    .score-form input:focus {
      outline: none;
      border-color: rgba(127, 219, 255, 0.8);
    }

    .submit-btn {
      background: linear-gradient(135deg, #ff9500, #ff6b00) !important;
      box-shadow: 0 4px 15px rgba(255, 149, 0, 0.4) !important;
      padding: 8px 15px !important;
      font-size: 0.85rem !important;
      white-space: nowrap;
    }

    .submit-btn:disabled {
      background: linear-gradient(135deg, #666, #444) !important;
      box-shadow: none !important;
      cursor: not-allowed;
    }

    .submit-status {
      font-size: 0.85rem;
      min-height: 1.2em;
      margin-bottom: 10px;
    }

    .score-note {
      font-size: 0.75rem;
      color: rgba(127, 219, 255, 0.6);
      margin-bottom: 8px;
    }

    .submit-status.success {
      color: #55efc4;
    }

    .submit-status.error {
      color: #ff6b6b;
    }

    @media (max-width: 360px) {
      .message {
        padding: 20px 15px;
        width: 95%;
      }
      
      .message h2 {
        font-size: 1.4rem;
      }
      
      .score-form {
        flex-direction: column;
        align-items: center;
      }
      
      .score-form input {
        width: 100%;
      }
      
      .submit-btn {
        width: 100%;
      }
    }

    /* ãƒ«ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 20, 40, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }

    .modal-overlay.show {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .modal {
      background: linear-gradient(180deg, rgba(0, 80, 120, 0.98), rgba(0, 40, 60, 0.98));
      color: #7fdbff;
      padding: 25px 30px;
      border-radius: 20px;
      max-width: 360px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      border: 2px solid rgba(127, 219, 255, 0.3);
      box-shadow: 0 0 50px rgba(0, 150, 200, 0.3);
      animation: popIn 0.3s ease;
    }

    @media (max-width: 360px) {
      .modal {
        padding: 20px 15px;
        width: 95%;
      }
      
      .modal h2 {
        font-size: 1.2rem;
      }
      
      .modal li {
        font-size: 0.85rem;
      }
    }

    .modal h2 {
      font-size: 1.4rem;
      margin-bottom: 15px;
      text-align: center;
      color: #7fdbff;
      text-shadow: 0 0 10px rgba(127, 219, 255, 0.5);
    }

    .modal ul {
      list-style: none;
      padding: 0;
      margin: 0 0 20px 0;
    }

    .modal li {
      padding: 8px 0;
      border-bottom: 1px solid rgba(127, 219, 255, 0.15);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .modal li:last-child {
      border-bottom: none;
    }

    .modal li::before {
      content: "ğŸ«§ ";
    }

    .modal .close-btn {
      display: block;
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #00a8cc, #006994);
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 168, 204, 0.4);
    }

    .help-btn {
      background: linear-gradient(135deg, #0088aa, #006688);
      box-shadow: 0 4px 15px rgba(0, 136, 170, 0.4);
      border: 1px solid rgba(127, 219, 255, 0.3);
    }

    .help-btn:hover {
      box-shadow: 0 4px 20px rgba(0, 136, 170, 0.6);
    }

    .ranking-btn {
      background: linear-gradient(135deg, #ffd700, #ff9500);
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
      border: 1px solid rgba(255, 215, 0, 0.3);
      color: #333;
    }

    .ranking-btn:hover {
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.6);
    }

    .retire-btn {
      background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      border: 1px solid rgba(255, 107, 107, 0.3);
    }

    .retire-btn:hover {
      box-shadow: 0 4px 20px rgba(255, 107, 107, 0.6);
    }

    .back-btn {
      background: linear-gradient(135deg, #666, #444);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .back-btn:hover {
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    .ranking-modal {
      max-width: 320px;
    }

    .ranking-content {
      max-height: 50vh;
      overflow-y: auto;
      margin-bottom: 15px;
    }

    .ranking-content .loading {
      text-align: center;
      color: rgba(127, 219, 255, 0.7);
    }

    .ranking-content .error {
      text-align: center;
      color: #ff6b6b;
    }

    .ranking-content .empty {
      text-align: center;
      color: rgba(127, 219, 255, 0.7);
    }

    .ranking-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .ranking-item {
      display: flex;
      align-items: center;
      padding: 10px 8px;
      border-bottom: 1px solid rgba(127, 219, 255, 0.15);
      gap: 8px;
    }

    .ranking-item:last-child {
      border-bottom: none;
    }

    .ranking-rank {
      font-weight: bold;
      font-size: 1rem;
      width: 26px;
      text-align: center;
      flex-shrink: 0;
    }

    .ranking-rank.gold { color: #ffd700; }
    .ranking-rank.silver { color: #c0c0c0; }
    .ranking-rank.bronze { color: #cd7f32; }

    .ranking-info {
      flex: 1;
      min-width: 0;
    }

    .ranking-name {
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.9rem;
    }

    .ranking-date {
      font-size: 0.7rem;
      color: rgba(127, 219, 255, 0.6);
    }

    .ranking-score {
      font-weight: bold;
      font-size: 1rem;
      color: #55efc4;
      flex-shrink: 0;
    }

    @media (max-width: 360px) {
      .ranking-modal {
        max-width: 95%;
      }
      
      .ranking-item {
        padding: 8px 5px;
        gap: 6px;
      }
      
      .ranking-rank {
        font-size: 0.9rem;
        width: 24px;
      }
      
      .ranking-name {
        font-size: 0.85rem;
      }
      
      .ranking-score {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <!-- èƒŒæ™¯ã®æ³¡ -->
  <div class="bubble-bg" style="left: 10%; animation-delay: 0s; width: 15px; height: 15px;"></div>
  <div class="bubble-bg" style="left: 20%; animation-delay: 2s; width: 25px; height: 25px;"></div>
  <div class="bubble-bg" style="left: 35%; animation-delay: 4s; width: 18px; height: 18px;"></div>
  <div class="bubble-bg" style="left: 50%; animation-delay: 1s; width: 22px; height: 22px;"></div>
  <div class="bubble-bg" style="left: 65%; animation-delay: 3s; width: 16px; height: 16px;"></div>
  <div class="bubble-bg" style="left: 80%; animation-delay: 5s; width: 20px; height: 20px;"></div>
  <div class="bubble-bg" style="left: 90%; animation-delay: 2.5s; width: 14px; height: 14px;"></div>

  <h1>ğŸ«§ Bubble Lines ğŸ«§</h1>
  
  <div class="info">
    <span>ã‚¹ã‚³ã‚¢: <strong id="score">0</strong></span>
    <span>ç©ºããƒã‚¹: <strong id="empty">78</strong></span>
  </div>

  <div class="next-balls">
    æ¬¡ã«å‡ºã‚‹ç‰: 
    <span id="nextBalls"></span>
  </div>

  <div class="board" id="board"></div>

  <div class="buttons">
    <button class="back-btn" id="backBtn">â† æˆ»ã‚‹</button>
    <button class="help-btn" id="helpBtn">ãƒ«ãƒ¼ãƒ«</button>
    <button class="ranking-btn" id="rankingBtn">ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
  </div>
  <div class="buttons">
    <button class="retire-btn" id="retireBtn">ãƒªã‚¿ã‚¤ã‚¢</button>
    <button class="reset-btn" id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <!-- ãƒ«ãƒ¼ãƒ«èª¬æ˜ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div class="modal-overlay" id="rulesModal">
    <div class="modal">
      <h2>ğŸ«§ ã‚ãã³ã‹ãŸ ğŸ«§</h2>
      <ul>
        <li>æ³¡ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠã—ã€ç©ºã„ã¦ã„ã‚‹ãƒã‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ç§»å‹•</li>
        <li>ç§»å‹•ã¯ç©ºããƒã‚¹ãŒã¤ãªãŒã£ã¦ã„ã‚‹å ´æ‰€ã®ã¿å¯èƒ½</li>
        <li>åŒã˜è‰²ã®æ³¡ã‚’ç¸¦ãƒ»æ¨ªãƒ»æ–œã‚ã«5ã¤ä»¥ä¸Šä¸¦ã¹ã‚‹ã¨æ¶ˆãˆã‚‹</li>
        <li>æ³¡ã‚’æ¶ˆã™ã¨ã‚¹ã‚³ã‚¢ãŒã‚‚ã‚‰ãˆã‚‹</li>
        <li>æ¯ã‚¿ãƒ¼ãƒ³3ã¤ã®æ–°ã—ã„æ³¡ãŒå‡ºç¾ã™ã‚‹</li>
        <li>æ³¡ã‚’æ¶ˆã—ãŸã‚¿ãƒ¼ãƒ³ã¯æ–°ã—ã„æ³¡ãŒå‡ºãªã„</li>
        <li>ãƒã‚¹ãŒå…¨éƒ¨åŸ‹ã¾ã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</li>
      </ul>
      <button class="close-btn" id="closeRulesBtn">OK</button>
    </div>
  </div>

  <!-- ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div class="modal-overlay" id="rankingModal">
    <div class="modal ranking-modal">
      <h2>ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚° ğŸ†</h2>
      <div id="rankingContent" class="ranking-content">
        <p class="loading">èª­ã¿è¾¼ã¿ä¸­...</p>
      </div>
      <button class="close-btn" id="closeRankingBtn">é–‰ã˜ã‚‹</button>
    </div>
  </div>

  <div class="message" id="message">
    <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
    <p>ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
    <div id="scoreForm" class="score-form">
      <input type="text" id="playerName" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="20">
      <button id="submitScoreBtn" class="submit-btn">ã‚¹ã‚³ã‚¢ç™»éŒ²</button>
    </div>
    <p class="score-note">â€»åŒã˜åå‰ã¯è‡ªå·±ãƒ™ã‚¹ãƒˆã®ã¿è¨˜éŒ²ã•ã‚Œã¾ã™</p>
    <p id="submitStatus" class="submit-status"></p>
    <button id="messageBtn">ã‚‚ã†ã„ã¡ã©</button>
  </div>

  <script>
    // ã‚²ãƒ¼ãƒ è¨­å®š
    const SIZE = 9;
    const COLORS = ['red', 'blue', 'green', 'yellow', 'purple'];
    const BALLS_PER_TURN = 3;
    const LINE_LENGTH = 5;
    const SAVE_KEY = 'bubbleLinesSave';

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let board = [];
    let selectedCell = null;
    let score = 0;
    let nextBalls = [];

    // ã‚»ãƒ¼ãƒ–
    function saveGame() {
      const saveData = {
        board: board,
        score: score,
        nextBalls: nextBalls,
        turnCount: turnCount
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    }

    // ãƒ­ãƒ¼ãƒ‰
    function loadGame() {
      const saveData = localStorage.getItem(SAVE_KEY);
      if (saveData) {
        try {
          const data = JSON.parse(saveData);
          board = data.board;
          score = data.score;
          nextBalls = data.nextBalls;
          turnCount = data.turnCount || 0;
          updateDisplay();
          renderBoard();
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    }

    // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿å‰Šé™¤
    function clearSave() {
      localStorage.removeItem(SAVE_KEY);
    }

    // åŠ¹æœéŸ³
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      if (type === 'move') {
        // æ°´ä¸­ã‚’ç§»å‹•ã™ã‚‹éŸ³
        oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.15);
      } else if (type === 'clear') {
        // æ³¡ãŒå¼¾ã‘ã‚‹éŸ³ï¼ˆãƒã‚³ãƒã‚³ï¼‰
        for (let i = 0; i < 5; i++) {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.frequency.setValueAtTime(800 + i * 100, audioCtx.currentTime + i * 0.05);
          osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + i * 0.05 + 0.1);
          osc.type = 'sine';
          gain.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.05 + 0.1);
          osc.start(audioCtx.currentTime + i * 0.05);
          osc.stop(audioCtx.currentTime + i * 0.05 + 0.15);
        }
        return;
      } else if (type === 'gameover') {
        // æ·±æµ·ã«æ²ˆã‚€éŸ³
        oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.8);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.8);
      }
    }

    // åˆæœŸåŒ–
    function initGame() {
      board = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));
      selectedCell = null;
      score = 0;
      turnCount = 0;
      
      // æ¬¡ã«å‡ºã‚‹ãƒœãƒ¼ãƒ«ã‚’æ±ºã‚ã‚‹
      nextBalls = generateNextBalls();
      
      // æœ€åˆã®ãƒœãƒ¼ãƒ«ã‚’é…ç½®
      addBalls();
      nextBalls = generateNextBalls();
      
      clearSave();
      updateDisplay();
      renderBoard();
    }

    // ã‚¿ãƒ¼ãƒ³æ•°ï¼ˆæ³¢ã®è¨ˆç®—ç”¨ï¼‰
    let turnCount = 0;

    // æ„åœ°æ‚ªãƒ¬ãƒ™ãƒ«ã‚’è¨ˆç®—ï¼ˆæ³¢ã®ã‚ã‚‹é›£æ˜“åº¦ï¼‰
    function getMeanLevel() {
      // ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«: ã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦ã‚†ã‚‹ã‚„ã‹ã«ä¸Šæ˜‡ï¼ˆ0ã€œ0.6ï¼‰
      const baseLevel = Math.min(0.6, score / 600 * 0.6);
      
      // æ³¢: ã‚µã‚¤ãƒ³æ³¢ã§Â±0.25ã®å¤‰å‹•ï¼ˆå‘¨æœŸã¯ç´„15ã‚¿ãƒ¼ãƒ³ï¼‰
      const wave = Math.sin(turnCount * 0.4) * 0.25;
      
      // ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ : Â±0.1ã®æºã‚‰ã
      const randomFactor = (Math.random() - 0.5) * 0.2;
      
      // åˆè¨ˆï¼ˆ0ã€œ0.9ã®ç¯„å›²ã«ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
      const level = Math.max(0, Math.min(0.9, baseLevel + wave + randomFactor));
      
      return level;
    }

    // æ¬¡ã«å‡ºã‚‹ãƒœãƒ¼ãƒ«ã‚’ç”Ÿæˆï¼ˆæ„åœ°æ‚ªç‰ˆï¼‰
    function generateNextBalls() {
      const balls = [];
      const meanLevel = getMeanLevel();
      
      for (let i = 0; i < BALLS_PER_TURN; i++) {
        if (Math.random() < meanLevel) {
          // æ„åœ°æ‚ªãƒ¢ãƒ¼ãƒ‰ï¼šç›¤é¢ã§å°‘ãªã„è‰²ã‚’é¸ã¶ï¼ˆæƒã„ã«ãããªã‚‹ï¼‰
          const colorCounts = {};
          COLORS.forEach(c => colorCounts[c] = 0);
          for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
              if (board[r][c]) colorCounts[board[r][c]]++;
            }
          }
          // ä¸€ç•ªå°‘ãªã„è‰²ã‚’é¸ã¶ï¼ˆãƒãƒ©ã‘ã•ã›ã‚‹ï¼‰
          const sortedColors = COLORS.slice().sort((a, b) => colorCounts[a] - colorCounts[b]);
          // å°‘ãªã„æ–¹ã‹ã‚‰2ã¤ã®è‰²ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
          balls.push(sortedColors[Math.floor(Math.random() * 2)]);
        } else {
          // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šå®Œå…¨ãƒ©ãƒ³ãƒ€ãƒ 
          balls.push(COLORS[Math.floor(Math.random() * COLORS.length)]);
        }
      }
      return balls;
    }

    // ã‚»ãƒ«ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆæ„åœ°æ‚ªé…ç½®ç”¨ï¼‰
    function calculateMeanScore(r, c, color) {
      let score = 0;
      const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
      
      // ã“ã®ä½ç½®ã«ç½®ãã¨ä½•å€‹æƒã†ã‹ç¢ºèªï¼ˆé‚ªé­”ã§ãã‚‹ã‹ï¼‰
      for (const [dr, dc] of directions) {
        let sameColorCount = 0;
        // æ­£æ–¹å‘
        let nr = r + dr, nc = c + dc;
        while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === color) {
          sameColorCount++;
          nr += dr;
          nc += dc;
        }
        // é€†æ–¹å‘
        nr = r - dr;
        nc = c - dc;
        while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === color) {
          sameColorCount++;
          nr -= dr;
          nc -= dc;
        }
        
        // 3ã€œ4å€‹æƒã£ã¦ã„ã‚‹å ´æ‰€ã«ã¯ç½®ã‹ãªã„ï¼ˆé‚ªé­”ã«ãªã‚‹ï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æœ‰åˆ©ï¼‰
        if (sameColorCount >= 3) {
          score -= 100;
        }
      }
      
      // ä»–ã®è‰²ã®ãƒ©ã‚¤ãƒ³ã‚’é‚ªé­”ã§ãã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      for (const otherColor of COLORS) {
        if (otherColor === color) continue;
        for (const [dr, dc] of directions) {
          let lineCount = 0;
          // æ­£æ–¹å‘
          let nr = r + dr, nc = c + dc;
          while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === otherColor) {
            lineCount++;
            nr += dr;
            nc += dc;
          }
          // é€†æ–¹å‘
          nr = r - dr;
          nc = c - dc;
          while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === otherColor) {
            lineCount++;
            nr -= dr;
            nc -= dc;
          }
          
          // 2ã€œ4å€‹æƒã£ã¦ã„ã‚‹å ´æ‰€ã«åˆ¥ã®è‰²ã‚’ç½®ãï¼ãƒ–ãƒ­ãƒƒã‚¯ï¼
          if (lineCount >= 2 && lineCount < 5) {
            score += lineCount * 10;
          }
        }
      }
      
      // çµŒè·¯ã‚’å¡ãä½ç½®ã‚’å„ªå…ˆï¼ˆä¸­å¤®ä»˜è¿‘ï¼‰
      const centerDist = Math.abs(r - 4) + Math.abs(c - 4);
      score += (8 - centerDist) * 2;
      
      return score;
    }

    // ãƒœãƒ¼ãƒ«ã‚’è¿½åŠ ï¼ˆæ„åœ°æ‚ªé…ç½®ç‰ˆï¼‰
    function addBalls() {
      const emptyCells = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === null) {
            emptyCells.push({ r, c });
          }
        }
      }

      const meanLevel = getMeanLevel();
      
      // ãƒœãƒ¼ãƒ«ã‚’é…ç½®
      const ballsToAdd = Math.min(nextBalls.length, emptyCells.length);
      const usedCells = new Set();
      
      for (let i = 0; i < ballsToAdd; i++) {
        const color = nextBalls[i];
        let chosenCell;
        
        if (Math.random() < meanLevel && emptyCells.length > 3) {
          // æ„åœ°æ‚ªãƒ¢ãƒ¼ãƒ‰ï¼šã‚¹ã‚³ã‚¢ãŒé«˜ã„ä½ç½®ã‚’é¸ã¶
          const availableCells = emptyCells.filter(cell => !usedCells.has(`${cell.r},${cell.c}`));
          const scoredCells = availableCells.map(cell => ({
            ...cell,
            score: calculateMeanScore(cell.r, cell.c, color) + Math.random() * 5
          }));
          scoredCells.sort((a, b) => b.score - a.score);
          
          // ä¸Šä½3ã¤ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶ï¼ˆå°‘ã—äºˆæ¸¬ä¸èƒ½ã«ï¼‰
          const topN = Math.min(3, scoredCells.length);
          chosenCell = scoredCells[Math.floor(Math.random() * topN)];
        } else {
          // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šãƒ©ãƒ³ãƒ€ãƒ 
          const availableCells = emptyCells.filter(cell => !usedCells.has(`${cell.r},${cell.c}`));
          chosenCell = availableCells[Math.floor(Math.random() * availableCells.length)];
        }
        
        usedCells.add(`${chosenCell.r},${chosenCell.c}`);
        board[chosenCell.r][chosenCell.c] = color;
      }

      // é…ç½®å¾Œã«ãƒ©ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯
      checkAndRemoveLines();
    }

    // ç›¤é¢æç”»
    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;

          if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
            cell.classList.add('selected');
          }

          if (board[r][c]) {
            const ball = document.createElement('div');
            ball.className = `ball ${board[r][c]}`;
            cell.appendChild(ball);
          }

          cell.addEventListener('click', () => handleClick(r, c));
          boardEl.appendChild(cell);
        }
      }

      // æ¬¡ã®ãƒœãƒ¼ãƒ«è¡¨ç¤º
      const nextBallsEl = document.getElementById('nextBalls');
      nextBallsEl.innerHTML = nextBalls.map(color => 
        `<span class="preview-ball ball ${color}"></span>`
      ).join('');
    }

    // ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
    function handleClick(r, c) {
      // ãƒœãƒ¼ãƒ«ãŒã‚ã‚‹ã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯
      if (board[r][c]) {
        selectedCell = { r, c };
        renderBoard();
        return;
      }

      // ç©ºã®ã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ï¼ˆç§»å‹•å…ˆï¼‰
      if (selectedCell && board[r][c] === null) {
        const path = findPath(selectedCell.r, selectedCell.c, r, c);
        if (path) {
          const color = board[selectedCell.r][selectedCell.c];
          board[selectedCell.r][selectedCell.c] = null;
          const fromR = selectedCell.r;
          const fromC = selectedCell.c;
          selectedCell = null;
          
          // ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
          animateMove(fromR, fromC, r, c, color, path);
        }
      }
    }

    // ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    function animateMove(fromR, fromC, toR, toC, color, path) {
      const boardEl = document.getElementById('board');
      const boardRect = boardEl.getBoundingClientRect();
      const cellSize = 34; // cell width + gap
      
      // ç§»å‹•ã™ã‚‹ãƒœãƒ¼ãƒ«ã‚’ä½œæˆ
      const ball = document.createElement('div');
      ball.className = `ball ${color} moving`;
      document.body.appendChild(ball);
      
      // å…¨çµŒè·¯ï¼ˆé–‹å§‹åœ°ç‚¹å«ã‚€ï¼‰
      const fullPath = [{ r: fromR, c: fromC }, ...path];
      let currentStep = 0;
      
      function getCellCenter(r, c) {
        return {
          x: boardRect.left + 8 + c * cellSize + cellSize / 2 - 13,
          y: boardRect.top + 8 + r * cellSize + cellSize / 2 - 13
        };
      }
      
      // åˆæœŸä½ç½®
      const startPos = getCellCenter(fromR, fromC);
      ball.style.left = startPos.x + 'px';
      ball.style.top = startPos.y + 'px';
      
      renderBoard();
      
      function moveStep() {
        if (currentStep >= fullPath.length - 1) {
          // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
          ball.remove();
          board[toR][toC] = color;
          playSound('move');
          
          renderBoard();

          // ãƒ©ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯
          const cleared = checkAndRemoveLines();
          
          // ãƒ©ã‚¤ãƒ³ãŒæ¶ˆãˆãªã‹ã£ãŸå ´åˆã®ã¿æ–°ã—ã„ãƒœãƒ¼ãƒ«ã‚’è¿½åŠ 
          if (!cleared) {
            setTimeout(() => {
              addBallsWithAnimation();
            }, 100);
          } else {
            updateDisplay();
            renderBoard();
            saveGame();
            checkGameOver();
          }
          return;
        }
        
        currentStep++;
        const nextCell = fullPath[currentStep];
        const nextPos = getCellCenter(nextCell.r, nextCell.c);
        
        // è»Œè·¡ã‚’æ®‹ã™
        const trail = document.createElement('div');
        trail.className = `trail ball ${color}`;
        const currentPos = getCellCenter(fullPath[currentStep - 1].r, fullPath[currentStep - 1].c);
        trail.style.left = (currentPos.x + 5) + 'px';
        trail.style.top = (currentPos.y + 5) + 'px';
        document.body.appendChild(trail);
        setTimeout(() => trail.remove(), 300);
        
        ball.style.left = nextPos.x + 'px';
        ball.style.top = nextPos.y + 'px';
        
        setTimeout(moveStep, 50);
      }
      
      setTimeout(moveStep, 50);
    }

    // ãƒœãƒ¼ãƒ«è¿½åŠ ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ»æ„åœ°æ‚ªé…ç½®ç‰ˆï¼‰
    function addBallsWithAnimation() {
      const emptyCells = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === null) {
            emptyCells.push({ r, c });
          }
        }
      }

      const meanLevel = getMeanLevel();
      
      // ãƒœãƒ¼ãƒ«ã‚’é…ç½®ï¼ˆæ„åœ°æ‚ªé…ç½®ï¼‰
      const ballsToAdd = Math.min(nextBalls.length, emptyCells.length);
      const usedCells = new Set();
      const placementCells = [];
      
      for (let i = 0; i < ballsToAdd; i++) {
        const color = nextBalls[i];
        let chosenCell;
        
        if (Math.random() < meanLevel && emptyCells.length > 3) {
          // æ„åœ°æ‚ªãƒ¢ãƒ¼ãƒ‰
          const availableCells = emptyCells.filter(cell => !usedCells.has(`${cell.r},${cell.c}`));
          const scoredCells = availableCells.map(cell => ({
            ...cell,
            score: calculateMeanScore(cell.r, cell.c, color) + Math.random() * 5
          }));
          scoredCells.sort((a, b) => b.score - a.score);
          
          const topN = Math.min(3, scoredCells.length);
          chosenCell = scoredCells[Math.floor(Math.random() * topN)];
        } else {
          // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰
          const availableCells = emptyCells.filter(cell => !usedCells.has(`${cell.r},${cell.c}`));
          chosenCell = availableCells[Math.floor(Math.random() * availableCells.length)];
        }
        
        usedCells.add(`${chosenCell.r},${chosenCell.c}`);
        placementCells.push({ ...chosenCell, color });
      }
      
      const boardEl = document.getElementById('board');
      const boardRect = boardEl.getBoundingClientRect();
      const cellSize = 34;
      
      // ã€Œæ¬¡ã«å‡ºã‚‹ç‰ã€ã®ä½ç½®ã‚’å–å¾—
      const nextBallsEl = document.getElementById('nextBalls');
      const previewBalls = nextBallsEl.querySelectorAll('.preview-ball');
      
      let animationsComplete = 0;
      
      for (let i = 0; i < placementCells.length; i++) {
        const cell = placementCells[i];
        const color = cell.color;
        
        // è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒœãƒ¼ãƒ«ã‚’ä½œæˆ
        const ball = document.createElement('div');
        ball.className = `ball ${color} moving`;
        document.body.appendChild(ball);
        
        // ç›®æ¨™ä½ç½®
        const targetX = boardRect.left + 8 + cell.c * cellSize + cellSize / 2 - 13;
        const targetY = boardRect.top + 8 + cell.r * cellSize + cellSize / 2 - 13;
        
        // é–‹å§‹ä½ç½®ï¼ˆã€Œæ¬¡ã«å‡ºã‚‹ç‰ã€ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ï¼‰
        let startX, startY;
        if (previewBalls[i]) {
          const previewRect = previewBalls[i].getBoundingClientRect();
          startX = previewRect.left - 3;
          startY = previewRect.top - 3;
        } else {
          startX = targetX;
          startY = boardRect.top - 50;
        }
        
        ball.style.left = startX + 'px';
        ball.style.top = startY + 'px';
        
        // é…å»¶ã‚’ã¤ã‘ã¦é †ç•ªã«ç™ºå°„
        setTimeout(() => {
          animateFly(ball, startX, startY, targetX, targetY, color, () => {
            ball.remove();
            board[cell.r][cell.c] = color;
            animationsComplete++;
            
            // å…¨éƒ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚ã‚ã£ãŸã‚‰ãƒã‚§ãƒƒã‚¯
            if (animationsComplete >= placementCells.length) {
              turnCount++;
              nextBalls = generateNextBalls();
              setTimeout(() => {
                checkAndRemoveLines();
                updateDisplay();
                renderBoard();
                saveGame();
                checkGameOver();
              }, 100);
            }
          });
        }, i * 200);
      }
      
      // ãƒœãƒ¼ãƒ«ã‚’è¿½åŠ ã—ãªã‹ã£ãŸå ´åˆ
      if (placementCells.length === 0) {
        nextBalls = generateNextBalls();
        updateDisplay();
        renderBoard();
        checkGameOver();
      }
    }
    
    // é£›ã‚“ã§ã„ãã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    function animateFly(ball, startX, startY, endX, endY, color, onComplete) {
      const duration = 350;
      const startTime = performance.now();
      const distanceX = endX - startX;
      const distanceY = endY - startY;
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚†ã£ãã‚Šå§‹ã¾ã£ã¦ã‚†ã£ãã‚Šçµ‚ã‚ã‚‹ï¼‰
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        const currentX = startX + distanceX * easeProgress;
        const currentY = startY + distanceY * easeProgress;
        
        ball.style.left = currentX + 'px';
        ball.style.top = currentY + 'px';
        
        // è»Œè·¡ã‚’æ®‹ã™
        if (progress < 1 && Math.random() < 0.4) {
          const trail = document.createElement('div');
          trail.className = `trail ball ${color}`;
          trail.style.left = (currentX + 5) + 'px';
          trail.style.top = (currentY + 5) + 'px';
          document.body.appendChild(trail);
          setTimeout(() => trail.remove(), 300);
        }
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          onComplete();
        }
      }
      
      requestAnimationFrame(animate);
    }

    // çµŒè·¯æ¢ç´¢ï¼ˆBFSï¼‰
    function findPath(fromR, fromC, toR, toC) {
      const visited = Array(SIZE).fill(null).map(() => Array(SIZE).fill(false));
      const queue = [{ r: fromR, c: fromC, path: [] }];
      visited[fromR][fromC] = true;

      const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

      while (queue.length > 0) {
        const current = queue.shift();

        if (current.r === toR && current.c === toC) {
          return current.path;
        }

        for (const [dr, dc] of directions) {
          const nr = current.r + dr;
          const nc = current.c + dc;

          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && 
              !visited[nr][nc] && board[nr][nc] === null) {
            visited[nr][nc] = true;
            queue.push({ 
              r: nr, 
              c: nc, 
              path: [...current.path, { r: nr, c: nc }]
            });
          }
        }
      }

      return null; // çµŒè·¯ãªã—
    }

    // ãƒ©ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯ã¨å‰Šé™¤
    function checkAndRemoveLines() {
      const toRemove = new Set();

      // å…¨æ–¹å‘ãƒã‚§ãƒƒã‚¯
      const directions = [
        [0, 1],   // æ¨ª
        [1, 0],   // ç¸¦
        [1, 1],   // æ–œã‚å³ä¸‹
        [1, -1]   // æ–œã‚å·¦ä¸‹
      ];

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (!board[r][c]) continue;

          const color = board[r][c];

          for (const [dr, dc] of directions) {
            const line = [{ r, c }];

            // æ­£æ–¹å‘
            let nr = r + dr;
            let nc = c + dc;
            while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === color) {
              line.push({ r: nr, c: nc });
              nr += dr;
              nc += dc;
            }

            // é€†æ–¹å‘
            nr = r - dr;
            nc = c - dc;
            while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc] === color) {
              line.push({ r: nr, c: nc });
              nr -= dr;
              nc -= dc;
            }

            if (line.length >= LINE_LENGTH) {
              line.forEach(cell => toRemove.add(`${cell.r},${cell.c}`));
            }
          }
        }
      }

      // å‰Šé™¤ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
      if (toRemove.size > 0) {
        // ã¾ãšã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
        const boardEl = document.getElementById('board');
        const boardRect = boardEl.getBoundingClientRect();
        const cellSize = 34;
        
        toRemove.forEach(key => {
          const [r, c] = key.split(',').map(Number);
          const cellIndex = r * SIZE + c;
          const cell = boardEl.children[cellIndex];
          const ball = cell.querySelector('.ball');
          if (ball) {
            ball.classList.add('removing');
            
            // å°ã•ãªæ³¡ã‚’è¤‡æ•°ç”Ÿæˆ
            const ballRect = ball.getBoundingClientRect();
            const centerX = ballRect.left + ballRect.width / 2;
            const centerY = ballRect.top + ballRect.height / 2;
            
            for (let i = 0; i < 6; i++) {
              setTimeout(() => {
                const bubble = document.createElement('div');
                bubble.className = 'pop-bubble';
                const angle = (i / 6) * Math.PI * 2;
                const distance = 15 + Math.random() * 10;
                bubble.style.left = (centerX + Math.cos(angle) * distance - 4) + 'px';
                bubble.style.top = (centerY + Math.sin(angle) * distance - 4) + 'px';
                document.body.appendChild(bubble);
                setTimeout(() => bubble.remove(), 800);
              }, i * 30);
            }
          }
        });
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«å®Ÿéš›ã«å‰Šé™¤
        setTimeout(() => {
          toRemove.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            board[r][c] = null;
          });
          score += toRemove.size * 2;
          updateDisplay();
          renderBoard();
        }, 400);
        
        playSound('clear');
        return true;
      }

      return false;
    }

    // è¡¨ç¤ºæ›´æ–°
    function updateDisplay() {
      document.getElementById('score').textContent = score;
      
      let empty = 0;
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === null) empty++;
        }
      }
      document.getElementById('empty').textContent = empty;
    }

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒã‚§ãƒƒã‚¯
    function checkGameOver() {
      let empty = 0;
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === null) empty++;
        }
      }

      if (empty === 0) {
        document.getElementById('finalScore').textContent = score;
        resetScoreForm();
        document.getElementById('message').classList.add('show');
        clearSave();
        playSound('gameover');
      }
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
    document.getElementById('backBtn').addEventListener('click', () => {
      // ã‚»ãƒ¼ãƒ–ã—ã¦ã‹ã‚‰æˆ»ã‚‹
      saveGame();
      window.location.href = 'index.html';
    });
    document.getElementById('resetBtn').addEventListener('click', initGame);
    document.getElementById('retireBtn').addEventListener('click', () => {
      if (score === 0) {
        alert('ã¾ã ã‚²ãƒ¼ãƒ ãŒå§‹ã¾ã£ã¦ã„ã¾ã›ã‚“');
        return;
      }
      if (confirm('ãƒªã‚¿ã‚¤ã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
        forceGameOver();
      }
    });
    document.getElementById('messageBtn').addEventListener('click', () => {
      document.getElementById('message').classList.remove('show');
      initGame();
    });

    // å¼·åˆ¶ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆãƒªã‚¿ã‚¤ã‚¢ç”¨ï¼‰
    function forceGameOver() {
      document.getElementById('finalScore').textContent = score;
      resetScoreForm();
      document.getElementById('message').classList.add('show');
      clearSave();
      playSound('gameover');
    }

    // ã‚¹ã‚³ã‚¢ç™»éŒ²
    // â€»ã“ã“ã«GASã®Webã‚¢ãƒ—ãƒªURLã‚’è¨­å®šã—ã¦ãã ã•ã„
    const GAS_URL = 'https://script.google.com/macros/s/AKfycbwU84QkVDt02rRjoeYFhh7MjOstgiC-fsoGVn0CSab6kYWHV7rSMcghOyExSwt3RoGk/exec';

    document.getElementById('submitScoreBtn').addEventListener('click', async () => {
      const nameInput = document.getElementById('playerName');
      const submitBtn = document.getElementById('submitScoreBtn');
      const statusEl = document.getElementById('submitStatus');
      const playerName = nameInput.value.trim();
      
      if (!playerName) {
        statusEl.textContent = 'åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        statusEl.className = 'submit-status error';
        return;
      }
      
      if (GAS_URL === 'YOUR_GAS_WEB_APP_URL') {
        statusEl.textContent = 'GAS URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“';
        statusEl.className = 'submit-status error';
        return;
      }
      
      submitBtn.disabled = true;
      statusEl.textContent = 'é€ä¿¡ä¸­...';
      statusEl.className = 'submit-status';
      
      try {
        const response = await fetch(GAS_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: `name=${encodeURIComponent(playerName)}&score=${score}`
        });
        
        statusEl.textContent = 'ç™»éŒ²ã—ã¾ã—ãŸï¼';
        statusEl.className = 'submit-status success';
        nameInput.disabled = true;
      } catch (error) {
        statusEl.textContent = 'ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ';
        statusEl.className = 'submit-status error';
        submitBtn.disabled = false;
      }
    });

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã«ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
    function resetScoreForm() {
      const nameInput = document.getElementById('playerName');
      const submitBtn = document.getElementById('submitScoreBtn');
      const statusEl = document.getElementById('submitStatus');
      nameInput.value = localStorage.getItem('bubbleLinesPlayerName') || '';
      nameInput.disabled = false;
      submitBtn.disabled = false;
      statusEl.textContent = '';
      statusEl.className = 'submit-status';
    }

    // åå‰ã‚’ä¿å­˜
    document.getElementById('playerName').addEventListener('change', (e) => {
      localStorage.setItem('bubbleLinesPlayerName', e.target.value);
    });

    // ãƒ«ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«
    document.getElementById('helpBtn').addEventListener('click', () => {
      document.getElementById('rulesModal').classList.add('show');
    });
    document.getElementById('closeRulesBtn').addEventListener('click', () => {
      document.getElementById('rulesModal').classList.remove('show');
    });
    document.getElementById('rulesModal').addEventListener('click', (e) => {
      if (e.target.id === 'rulesModal') {
        document.getElementById('rulesModal').classList.remove('show');
      }
    });

    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«
    document.getElementById('rankingBtn').addEventListener('click', () => {
      document.getElementById('rankingModal').classList.add('show');
      loadRanking();
    });
    document.getElementById('closeRankingBtn').addEventListener('click', () => {
      document.getElementById('rankingModal').classList.remove('show');
    });
    document.getElementById('rankingModal').addEventListener('click', (e) => {
      if (e.target.id === 'rankingModal') {
        document.getElementById('rankingModal').classList.remove('show');
      }
    });

    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°èª­ã¿è¾¼ã¿
    async function loadRanking() {
      const contentEl = document.getElementById('rankingContent');
      contentEl.innerHTML = '<p class="loading">èª­ã¿è¾¼ã¿ä¸­...</p>';
      
      if (GAS_URL === 'YOUR_GAS_WEB_APP_URL') {
        contentEl.innerHTML = '<p class="error">GAS URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“</p>';
        return;
      }
      
      try {
        const response = await fetch(GAS_URL);
        const data = await response.json();
        
        if (!data.success) {
          throw new Error(data.message);
        }
        
        if (data.ranking.length === 0) {
          contentEl.innerHTML = '<p class="empty">ã¾ã ã‚¹ã‚³ã‚¢ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>';
          return;
        }
        
        const listHtml = data.ranking.map((item, index) => {
          const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
          const rankIcon = index === 0 ? 'ğŸ‘‘' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}`;
          const dateStr = formatDate(item.date);
          
          return `
            <li class="ranking-item">
              <span class="ranking-rank ${rankClass}">${rankIcon}</span>
              <div class="ranking-info">
                <div class="ranking-name">${escapeHtml(item.name)}</div>
                <div class="ranking-date">${dateStr}</div>
              </div>
              <span class="ranking-score">${item.score}</span>
            </li>
          `;
        }).join('');
        
        contentEl.innerHTML = `<ul class="ranking-list">${listHtml}</ul>`;
        
      } catch (error) {
        contentEl.innerHTML = '<p class="error">èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>';
      }
    }

    // æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    function formatDate(dateStr) {
      if (!dateStr) return '';
      
      // æ—¢ã« yyyy/MM/dd å½¢å¼ã®å ´åˆ
      if (dateStr.match(/^\d{4}\/\d{2}\/\d{2}/)) {
        return dateStr.split(' ')[0];
      }
      
      // ISOå½¢å¼ï¼ˆ2026-01-12T06:06:33.000Zï¼‰ã®å ´åˆ
      try {
        const date = new Date(dateStr);
        if (!isNaN(date.getTime())) {
          const y = date.getFullYear();
          const m = String(date.getMonth() + 1).padStart(2, '0');
          const d = String(date.getDate()).padStart(2, '0');
          return `${y}/${m}/${d}`;
        }
      } catch (e) {}
      
      // ãã®ä»–ã®å½¢å¼ã¯ãã®ã¾ã¾è¿”ã™
      return dateStr.split('T')[0] || dateStr;
    }

    // HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    if (!loadGame()) {
      initGame();
    }

    // ãƒšãƒ¼ã‚¸ã‚’é›¢ã‚Œã‚‹æ™‚ã«è‡ªå‹•ä¿å­˜
    window.addEventListener('beforeunload', () => {
      saveGame();
    });
    
    // visibilitychange ã§ã‚‚ä¿å­˜ï¼ˆãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œï¼‰
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        saveGame();
      }
    });
  </script>
</body>
</html>
